         nam   Boot         ttl   os9 system module* Disassembled 2014/12/18 20:12:46 by Disasm v1.5 (C) 1988 by RMLLevel    equ 2         ifp1         use   /dd/defs/os9defs         use   /dd/defs/rbfdefs         endctylg     set   Systm+Objctatrv     set   ReEnt+revrev      set   $00         mod   eom,name,tylg,atrv,start,sizeu0000    rmb   2u0002    rmb   2u0004    rmb   2u0006    rmb   2u0008    rmb   2u000A    rmb   1u000B    rmb   1u000C    rmb   1u000D    rmb   1u000E    rmb   1size     equ   .name     equ   *         fcs   /Boot/         fcb   $09* HWInit - initialize the deviceL0012    lda   #$D0         force interrupt (stops command in progress)         sta   8,y          write command to register         lbsr  L01AE        delay         lda   8,y          clear satus register         lda   #$ff         sta   $0b,u        set current track         leax  L0129,pc     point to NMI         stx   <D.NMI       save it in DP         lda   #$08         turn motor on         ora   L01CC,pc         sta   ,y         ldd   #$F000       delayL001E    nop         nop         subd  #1         bne   L001E* HWTerm - terminate the deviceL0037    clrb         stb   ,y           turn off all drives         rtsstart    equ   *         orcc  #IntMasks    ensure IRQs are off         leas  -$0F,s       allocate data area on stack         tfr   s,u          get pointer to data area         pshs  u            save it         ldd   #$0100         os9   F$SRqMem         bcs   L0087         bsr   L0099         ldy   L01CA,pc     get hardware address         lbsr  L0012        initialize it         ldx   #$0000       set sector to 0         lbsr  L00EF        read LSN0         bcs   L008B         lda   #'0         jsr   <D.BtBug         stx   $08,u        save LSN0 pointer         lda   DD.TKS,x     number of tracks         ldb   DD.FMT,x     disk format byte         std   $0c,u         ldd   DD.BSZ,x     os9boot size         beq   L00A0        if zero do frag boot         std   $06,u        save it         leax  DD.BT,x         addd  #$00FF       round up to next page         sta   4,x          save file size         clr   6,x          make next segment entry 0         clr   7,x         bra   L00B0* return to krnL007F    lbsr  L0037        terminate         ldx   u0004,u         clrb         ldd   u0006,uL0087    leas  <$11,s         rtsL008B    pshs  cc         ldd   #$0100         ldu   u0002,u         os9   F$SRtMem         puls  cc         bra   L0087L0099    tfr   u,d          save pointer to requested memory         ldu   $02,s        recover pointer to data stack         std   u0002,u      save block location         rtsL00A0    ldb   <$15,x         ldx   <$16,x         lbsr  L00EF         ldd   $0B,x         std   u0006,u         leax  <$10,xL00B0    os9   F$BtMem         bcs   L008B         bsr   L0099         std   u0004,u      save block imageL00B9    stx   ,u           update segment listL00BB    ldx   FDSL.A+1,x   LSW sector location         beq   L007F         lbsr  L00EF         inc   u0002,u         lda   #'.         jsr   <D.BtBug         ldx   ,u         dec   $04,x         beq   L00D7         ldd   $01,x         addd  #$0001         std   $01,x         bra   L00BBL00D7    leax  $05,x         bra   L00B9* DoDDnsL00DB    lda   #$28         double density enable and motor on         ora   L01CC,pc         sta   u000A,u      save drive selection         clr   u000B,u      clear current track         lda   #$05         lbsr  L0186        set track to the head we want         ldb   #$00         RESTORE cmd         lbra  L01A3        send command and wait for it to complete* HWRead read a 256 byte sector from the deviceL00EF    lda   #$91         bsr   L0101        else branch         bcs   L00F8         ldx   u0002,u      get sector buffer pointer for caller         clrbL00F8    rtsL00F9    bcc   L0101         pshs  x,b,a         bsr   L00DB        do double density         puls  x,b,aL0101    pshs  x,b,a        save LSN         bsr   L010C        read sector         puls  x,b,a        restore LSN         bcc   L00F8         lsra         bne   L00F9* read sector from diskL010C    bsr   L0149        seek to sector         bcs   L00F8         ldx   u0002,u      get sector buffer pointer         orcc  #IntMasks         pshs  x         ldx   #$FFFF         ldb   #$80         get READ sector command         stb   $08,y        write to command register         ldb   u000A,u         orb   #$30         tst   u000E,u         beq   L0127         orb   #$40L0127    stb   ,y         lbsr  L01AE        delay 54~         orb   #$80         HALT enable         stb   ,y         nop         nop         ldx   ,s* sector read loopL0134    lda   $0B,y         sta   ,x+         nop         bra   L0134* NMI routineL0129    leas  $0E,s         puls  x         ldb   $08,y         bitb  #$9C         beq   L0148         comb         ldb   #$F4L0148    rts* seek to sectorL0149    lda   #$08         ora   >L01CC,pcr         sta   u000A,u         clr   u000E,u         tfr   x,d         cmpd  #$0000         beq   L0183         clr   ,-s         pshs  a         lda   u000D,u         bita  #$01         puls  a         beq   L0179         bra   L016F* double-sided codeL0169    com   u000E,u         bne   L016F         inc   ,sL016F    subb  u000C,u         sbca  #$00         bcc   L0169         bra   L017FL0177    inc   ,sL0179    subb  u000C,u         sbca  #$00         bcc   L0177L017F    addb  u000C,u         puls  aL0183    incb         stb   $0A,yL0186    ldb   u000B,u         stb   $09,y         cmpa  u000B,u         beq   L01A1         sta   u000B,u         sta   $0B,y         ldb   #$10         bsr   L01A3         pshs  x* seek delay         ldx   #$222EL019B    leax  -$01,x         bne   L019B         puls  xL01A1    clrb         rtsL01A3    bsr   L01ACL01A5    ldb   $08,y         bitb  #$01         bne   L01A5         rtsL01AC    bsr   L01B6L01AE    lda   #$05L01B0    exg   a,a         deca         bne   L01B0         rtsL01B6    lda   u000A,u         sta   ,y         stb   $08,y         rts         fcb   $39,$39,$39,$39,$39,$39,$39         fcb   $39,$39,$39,$39,$39,$39L01CA    fdb   $ff40L01CC    fcb   $01         emodeom      equ   *         end         nam   Boot         ttl   os9 system module* Disassembled 2014/12/18 20:12:46 by Disasm v1.5 (C) 1988 by RMLLevel    equ 2         ifp1         use   /dd/defs/os9defs         use   /dd/defs/rbfdefs         endctylg     set   Systm+Objctatrv     set   ReEnt+revrev      set   $00         mod   eom,name,tylg,atrv,start,sizeu0000    rmb   2u0002    rmb   2u0004    rmb   2u0006    rmb   2u0008    rmb   2u000A    rmb   1u000B    rmb   1u000C    rmb   1u000D    rmb   1u000E    rmb   1size     equ   .name     equ   *         fcs   /Boot/         fcb   $09* HWInit - initialize the deviceL0012    lda   #$D0         force interrupt (stops command in progress)         sta   8,y          write command to register         lbsr  L01AE        delay         lda   8,y          clear satus register         lda   #$ff         sta   $0b,u        set current track         leax  L0129,pc     point to NMI         stx   <D.NMI       save it in DP         lda   #$08         turn motor on         ora   L01CC,pc         sta   ,y         ldd   #$F000       delayL001E    nop         nop         subd  #1         bne   L001E* HWTerm - terminate the deviceL0037    clrb         stb   ,y           turn off all drives         rtsstart    equ   *         orcc  #IntMasks    ensure IRQs are off         leas  -$0F,s       allocate data area on stack         tfr   s,u          get pointer to data area         pshs  u            save it         ldd   #$0100         os9   F$SRqMem         bcs   L0087         bsr   L0099         ldy   L01CA,pc     get hardware address         lbsr  L0012        initialize it         ldx   #$0000       set sector to 0         lbsr  L00EF        read LSN0         bcs   L008B         lda   #'0         jsr   <D.BtBug         stx   $08,u        save LSN0 pointer         lda   DD.TKS,x     number of tracks         ldb   DD.FMT,x     disk format byte         std   $0c,u         ldd   DD.BSZ,x     os9boot size         beq   L00A0        if zero do frag boot         std   $06,u        save it         leax  DD.BT,x         addd  #$00FF       round up to next page         sta   4,x          save file size         clr   6,x          make next segment entry 0         clr   7,x         bra   L00B0* return to krnL007F    lbsr  L0037        terminate         ldx   u0004,u         clrb         ldd   u0006,uL0087    leas  <$11,s         rtsL008B    pshs  cc         ldd   #$0100         ldu   u0002,u         os9   F$SRtMem         puls  cc         bra   L0087L0099    tfr   u,d          save pointer to requested memory         ldu   $02,s        recover pointer to data stack         std   u0002,u      save block location         rtsL00A0    ldb   <$15,x         ldx   <$16,x         lbsr  L00EF         ldd   $0B,x         std   u0006,u         leax  <$10,xL00B0    os9   F$BtMem         bcs   L008B         bsr   L0099         std   u0004,u      save block imageL00B9    stx   ,u           update segment listL00BB    ldx   FDSL.A+1,x   LSW sector location         beq   L007F         lbsr  L00EF         inc   u0002,u         lda   #'.         jsr   <D.BtBug         ldx   ,u         dec   $04,x         beq   L00D7         ldd   $01,x         addd  #$0001         std   $01,x         bra   L00BBL00D7    leax  $05,x         bra   L00B9* DoDDnsL00DB    lda   #$28         double density enable and motor on         ora   L01CC,pc         sta   u000A,u      save drive selection         clr   u000B,u      clear current track         lda   #$05         lbsr  L0186        set track to the head we want         ldb   #$00         RESTORE cmd         lbra  L01A3        send command and wait for it to complete* HWRead read a 256 byte sector from the deviceL00EF    lda   #$91         bsr   L0101        else branch         bcs   L00F8         ldx   u0002,u      get sector buffer pointer for caller         clrbL00F8    rtsL00F9    bcc   L0101         pshs  x,b,a         bsr   L00DB        do double density         puls  x,b,aL0101    pshs  x,b,a        save LSN         bsr   L010C        read sector         puls  x,b,a        restore LSN         bcc   L00F8         lsra         bne   L00F9* read sector from diskL010C    bsr   L0149        seek to sector         bcs   L00F8         ldx   u0002,u      get sector buffer pointer         orcc  #IntMasks         pshs  x         ldx   #$FFFF         ldb   #$80         get READ sector command         stb   $08,y        write to command register         ldb   u000A,u         orb   #$30         tst   u000E,u         beq   L0127         orb   #$40L0127    stb   ,y         lbsr  L01AE        delay 54~         orb   #$80         HALT enable         stb   ,y         nop         nop         ldx   ,s* sector read loopL0134    lda   $0B,y         sta   ,x+         nop         bra   L0134* NMI routineL0129    leas  $0E,s         puls  x         ldb   $08,y         bitb  #$9C         beq   L0148         comb         ldb   #$F4L0148    rts* seek to sectorL0149    lda   #$08         ora   >L01CC,pcr         sta   u000A,u         clr   u000E,u         tfr   x,d         cmpd  #$0000         beq   L0183         clr   ,-s         pshs  a         lda   u000D,u         bita  #$01         puls  a         beq   L0179         bra   L016F* double-sided codeL0169    com   u000E,u         bne   L016F         inc   ,sL016F    subb  u000C,u         sbca  #$00         bcc   L0169         bra   L017FL0177    inc   ,sL0179    subb  u000C,u         sbca  #$00         bcc   L0177L017F    addb  u000C,u         puls  aL0183    incb         stb   $0A,yL0186    ldb   u000B,u         stb   $09,y         cmpa  u000B,u         beq   L01A1         sta   u000B,u         sta   $0B,y         ldb   #$10         bsr   L01A3         pshs  x* seek delay         ldx   #$222EL019B    leax  -$01,x         bne   L019B         puls  xL01A1    clrb         rtsL01A3    bsr   L01ACL01A5    ldb   $08,y         bitb  #$01         bne   L01A5         rtsL01AC    bsr   L01B6L01AE    lda   #$05L01B0    exg   a,a         deca         bne   L01B0         rtsL01B6    lda   u000A,u         sta   ,y         stb   $08,y         rts         fcb   $39,$39,$39,$39,$39,$39,$39         fcb   $39,$39,$39,$39,$39,$39L01CA    fdb   $ff40L01CC    fcb   $01         emodeom      equ   *         end