         nam   OS9p1         ttl   os9 system module    * Disassembled 2014/11/20 19:45:13 by Disasm v1.5 (C) 1988 by RMLLevel    equ   2
H6309    equ   1
         ifp1         use   /dd/defs/os9defs         endctylg     set   Systm+$00atrv     set   ReEnt+revrev      set   $06         mod   eom,name,tylg,atrv,start,sizeu0000    rmb   0size     equ   .name     equ   *         fcs   /OS9p1/         fcb   $13          fcc   /0123456789ABCDEF/         fcc   /0123456789ABCDEF/         fcc   /0123456789ABCDEF/         fcc   /0123456789/* Dispatch table.
L0049    fdb   $fcad            D.Clock         fdb   $f240            D.XSWI3         fdb   $f24e            D.XSWI2         fdb   D.Crash          D.XFIRQ crash on FIRQ         fdb   $fd0c            D.XIRQ         fdb   $f243            D.XSWI         fdb   D.Crash          D.XNMI crash on an NMI         fdb   $0055            D.ErrRst ??? Not used as far as I can tell         fdb   $f309            Initial Kernel system call vectorL005B    aim   #$FE,<D.TINIT    map type 0
	 lde   <D.TINIT         another 2 bytes saved if GRFDRV does: tfr cc,e
	 ste   >DAT.Task        and we can use A here, instead of E
         clr   <D.SSTskN
         tfr   x,s
         tfr   a,cc
         rts	
L006C    jmp   [<-(D.SWI3-D.XSWI3),x]    (-$10) (Jmp to 2ndary vector)

* Let’s start by initializing system pagestart    ldq   #$01001F00       start address to clear & # bytes to clear         leay  <start+2,pc      point to 0         tfm   y,d+         std   <D.CCStk         set pointer to top of global memory to $2000         lda   #$01             set task user table to $0100         std   <D.Tasks         addb  #$20             set task image table to $0120         std   <D.TskIPt         clrb                   set memory block map to $0200         inca           std   <D.BlkMap         addb  #$40             set second block map to $0240         std   <D.BlkMap+2         clrb                   set system service dispatch table to $0300         inca         std   <D.SysDis         inca                   set user dispatch table to $0400
         std   <D.UsrDis
         inca                   set process descriptor block to $0500
         std   <D.PrcDBT
         inca                   set system process descriptor to $0600
         std   <D.SysPrc
         std   <D.Proc          set user process descriptor to $0600
         adda  #$02             set stack pointer to $0800
         tfr   d,s
         inca                   set system stack to $0900
         std   <D.SysStk
         std   <D.SysMem        set system memory map ptr $0900
         inca                   set module directory start to $0a00
         std   <D.ModDir
         std   <D.ModEnd        set module directory end to $0a00
         adda  #$06             set secondary module directory start to $1000
         std   <D.ModDir+2
         std   <D.ModDAT        set module directory DAT pointer to $1000
         std   <D.CCMem	set pointer to beginning of global memory to $1000
* In following line, CRC=ON if it is STA <D.CRC, CRC=OFF if it is a STB <D.CRC
         stb   <D.CRC           set CRC checking flag to off
		
* Initialize interrupt vector tables
         leay	<DisTable,pc    point to table of absolute vector addresses
         ldx	#D.Clock        where to put it in memory
         ldf   #$12             size of data         tfm   y+,x+            move it over         ldu   #$0160           somewhere in block 0 that’s never modified         stu   <D,Flip0         switch to system task 0         ldf   #$11             size of it         tfm   y+,u+            copy it over         tfr   y,u              move pointer to a faster registerL00CC    stu   ,x++             set all IRQ vectors to go to Vectors for now         cmpx  #D.NMI         bls   L00CC* Initialize user interrupt vectors         ldx   <D.XSWI2         get SWI2 (os9 command) service routine pointer         stx   <D.UsrSvc        save it as user service routine pointer         ldx   <D.XIRQ          get IRQ service routine pointer         stx   <D.UsrIRQ        save it as user IRQ routine pointer         leax  >L02ED,pc        setup system service routine entry vector         stx   <D.SysSvc         stx   <D.XSWI2         leax  >SysIRQ,pc       setup system IRQ service vector         stx   <D.SysIRQ         stx   <D.XIRQ         leax  >L0E01,pc        setup in system IRQ Service         stx   <D.SvcIRQ         leax  >L053C,pc        setup interrupt polling vector         stx   <D.Poll         leax  >L01C3,pc        setup alternate IRQ vector: pts to an rts         stx   <D.AltIRQ         lda   #’K              — in kernal         jsr   <D.BtBug         leax  >L0E5D,pc        setup change to task 1 vector         stx   <D.Flip1

* Setup System calls         leay  >L01D3,pcr         lbsr  L034D

* Initialize system process descriptor         ldu   <D.PrcDBT        get process table pointer         ldx   <D.SysPrc        get system process pointer

* These overlap because it is quicker than trying to strip hi byte from X         stx   ,u               save it as the first process in table         stx   1,u              save it as the second as well         oim   #$01,P$ID,x      set process ID to 1 (inited to 0)         oim   #SysState,P$State,x    set to system state         clra                   system task is task 0         sta   <D.SysTsk         sta   P$Task,x         coma                   setup its priority and age ($FF)         sta   P$Prior,x         sta   $0b,x         leax  <P$DATImg,x         stx   <D.SysDAT        save it as a pointer in DP         clrd           std   ,x++* Dat.BlCt-ROMCount-RAMCount         lda   #$06             initialize the rest of the blocks to be free         ldu   #DAT.FreeL0135    stu   ,x++         deca           bne   L0135         ldu   #$003F           block $3f is in use, at the top of system DAT image         stu   ,x         ldx   <D.Tasks         point to task user table         inc   ,x               mark first 2 in use (system & GrfDrv)         inc   1,x

* Setup system memory map         ldx   <D.SysMem         ldb   <D.CCStkL0149    inc   ,x+         decb           bne   L0149* Calculate memory size         ldx   <D.BlkMap         get pointer to 8k block map         inc   <$3F,x            mark block $3F as used (kernel)         ldq   #$00080100        E=marker, D=Block # to checkL0158    asld                    get next block #         stb   >$FFA5            map block into block 6 of my task         ste   >-$6000,x         save marker to that block         cmpe  ,x                did it ghost to block 0?         bne   L0158             no, keep going until ghost found         stb   <D.MemSz          save # of 8k mem blocks that exist         addr  x,d               add number of blocks to block map start         std   <D.BlkMap+2       save block map end pointer* [D] at this point will contain 1 of the following:
* $0210 - 128k
* $0220 - 256k
* $0240 - 512k
* $0280 - 1024k
* $0300 - 2048k
         bitb  #$30              block above 128-256k?         beq   L0181             yes no need to mark block map         tstb                    2 meg?         beq   L0181             yes skip this         abx                     add maximum block # to block map start         leax  -1,x              skip good blocks that are RAM         lda   #NotRam           not ram flag         subb  #$3F              calculate # blocks to mark as not ramL017C    sta   ,x+               mark them all         decb           bne   L017CL0181    ldx   #$ED00         lda   #$12         lbsr  L08E1         bsr   L01AF*see if Init module is in memory alreadyL018B    leax  <L01CB,pcr         bsr   L01C5         bcc   L0199         os9   F$Boot         bcc   L018B         bra   L01ABL0199    stu   <D.Init         lda   #’i         jsr   <D.BtBug* try calling os9p2L019F    leax  <L01CF,pcr         bsr   L01C5         bcc   L01AD         os9   F$Boot          bcc   L019FL01AB    jmp   <D.CrashL01AD    jmp   ,y*Mark kernel in system memory map as used memory (256 byte blocks)L01AF    ldx   <D.SysMem         ldd   #$80ED         abx            comb           sta   b,x         lda   #$01L01BA    sta   ,x+         decb           bne   L01BA         ldx   <D.BlkMap         sta   <$3F,x         rts   *Link module pointed to by XL01C5    lda   #$C0         os9   F$Link            rts   L01CB    fcs   /Init/
L01CF    fcs   /OS9P2/L01D4    fcb   F$Link
         fdb   $018b
         fcb   F$PrsNam
         fdb   $0506
         fcb   F$CmpName
         fdb   $0593
         fcb   $91              F$CmpNam (sys state)
         fdb   $059b
         fcb   $17
         fdb   $0409
         fcb   $a8
         fdb   $05f2
         fcb   $a9
         fdb   $0646
         fcb   $ac
         fdb   $0d0a
         fcb   $f9
         fdb   $ad0b
         fcb   $75
         fdb   $ae02
         fcb   $2e
         fdb   $b201
         fcb   $42
         fdb   $b401
         fcb   $5d
         fdb   $b506
         fcb   $90
         fdb   $b605
         fcb   $da
         fdb   $1b08
         fcb   $f8
         fdb   $b809
         fcb   $43
         fdb   $3907
         fcb   $2a
         fdb   $ba07
         fcb   $91
         fdb   $bc08
         fcb   $4e
         fdb   $bd08
         fcb   $38
         fdb   $be07
         fcb   $ef
         fdb   $bf0d
         fcb   $0a
         fdb   $2cc0
         fcb   $0d
         fdb   $0a39
         fcb   $c1
         fdb   $0d0a
         fcb   $46
         fdb   $c20d
         fcb   $0a
         fdb   $64c3
         fcb   $0d
         fdb   $0a7f
         fcb   $c4
         fdb   $0851
         fcb   $c6
         fdb   $0867
         fcb   $c8
         fdb   $08a2
         fcb   $c9
         fdb   $09de
         fcb   $ca
         fdb   $09f6
         fcb   $cd
         fdb   $0126
         fcb   $ce
         fdb   $03f5
         fcb   $d3
         fdb   $0725
         fcb   $d7
         fdb   $06a0
         fcb   $51
         fdb   $0736

         fcb   $80
* SWI3 vector entryL0247    lda   #P$SWI3          get pointer to dwi3 vector
         fcb   $8c              skip 2 bytes

*SWI vector entry
L024A    lda   #P$SWI           get pointer to swi vector         ldx   <D.Proc          get process pointer         ldu   a,x              user defined swi[x]?         beq   L025F            yes, go call users routine         lbra  L0E69* SWI2 vector entry         ldx   <D.Proc          get current process descriptor         ldu   <P$SWI2,x        any SWI2 vector?         bne   L0253            yes, ???* Process software interrupts from a user state
* Entry: X=Process descriptor pointer of process that made the system call
*        U=Register stack pointerL0253    ldu   <D.SysSvc        set system call professor to system sideL025F    stu   <D.SWI2         ldu   <D.SysIRQ        do the same for IRQ’s         stu   <D.XIRQ         oim   #SysState,P$State,x
* copy register stack to process descripor         sts   P$SP,x         leas  (P$Stack-R$Size),x         leau  R$Size-1,s         leay  -1,y         ldw   #R$Size         tfm   y-,u-* next 2 lines are swapped vertically in krnp1 (probably for interrupt timing)         andcc #^IntMasks         leau  ,s               needed because TFM is u-, not -u (post not pre)* B=function code already from calling process: DON’T USE IT!         ldx   R$PC,u           get where PC was from process         leax  1,x              skip option byte         stx   R$PC,u           save updated PC to process
* execute function call         ldy   <D.UsrDis        get user dispatch table pointer         lbsr  L0313            go execute option         aim   #^IntMasks,R$CC,u    clear interupt flags in caller’s CC         ldx   <D.Proc          get process descriptor         aim   #^(SysState+TimeOut),P$State,x   clear system & timeout flags* Check for image change now, which lets stuff like F$MapBlk an F$ClrBlk
* do the short-circuit thing, too. adds about 20 cycles to each system call.         lbsr  L0C63         lda   P$State,x        get current state of the process         ora   P$Signal,x       is there a pending signal?         sta   <D.Quick         save quick return flag         beq   L02A3L0296    bsr   L02C9            move the stack frame back to user state         lbra  L0FAD            go back to the processL02A3    inc   <D.QCnt          increment quick number of system calls
         aim   #$1f,<D.QCnt     base 32?
         beq   L0296            yes every 32 system calls do a full check

         ldw   #$000E         ldy   #$FEDF         orcc  #IntMasks         tfm   u+,y+         lbra  L0DD9* copy register stack from user to system         pshs  u,y,x,cc         ldb   P$Task,x         ldx   P$SP,x         lbsr  L0BFE         leax  >-$6000,xL02C8    bra   L02D9* copy register stack from system to user         pshs  u,y,x,cc         ldb   P$Task,x         ldx   P$SP,x         lbsr  L0BFE         leax  >-$6000,xL02D7    exg   x,y
* copy a register stack
* Entry: X=source
*        Y=destination
*        A=offset into DAT image of block
*        B=task #L02D9    leau  a,u         lda   $01,u         ldb   $03,u         orcc  #$50         std   >$FFA5         ldw   #R$Size         tfm   x+,y+         ldx   <u004CL02ED    lda   $0B,x         ldb   $0D,x         std   >$FFA5         puls  pc,u,y,x,cc* Process software interupts from system state
* Entry: U=Register stack pointer         leau  ,s         lda   <D.SSTskN         clr   <D.SSTskN         pshs  a         lda   ,u         tfr   a,cc         ldx   $0C,u         leax  $01,x         stx   $0C,u         ldy   <u00C2         bsr   L0314         puls  a         lbra  L0E30* Entry: X = system call vector to jump to
         jmp   ,x* Execute system call
* Entry: B=Function call #
*        Y=Function dispatch table pointer (D.SysDis or D.UsrDis)
L0314    lslb           bcc   L0335         ldx   >IOEntry,yL031B    pshs  u         jsr   [D.SysVec]         puls  uL0323    tfr   cc,a         bcc   L0329         stb   $02,uL0329    ldb   ,u         andd  #$2FD0         orr   b,a         sta   ,u         rts   * Execute regular system calls
L0335    clra           ldx   d,y         bne   L031B         comb           ldb   #$D0         bra   L0323* System Call: F$SSVC
*
* Function: Install system calls
*
* Input:  Y = Address of service request init table
*
* Output: None
*
* Error:  CC = C bit set; B = error code
         ldy   $08,u         bra   L0356L0344    clra           lslb           tfr   d,u         ldd   ,y++         leax  d,y         ldd   <u00C2         stx   d,u         bcs   L0356         ldd   <D.UsrDis         stx   d,uL0356    ldb   ,y+         cmpb  #$80         bne   L0344         rts   * System Call: F$SLink
*
* Function: System Link
*
* Input:  A = Module type
*         X = Module name string pointer
*         Y = Name string DAT image pointer
*
* Output: A = Module type
*         B = Module revision
*         X = Updated name string pointer
*         Y = Module entry point
*         U = Module pointer
*
* Error:  CC = C bit set; B = error code
*         ldy   R$Y,u         bra   L036F* System Call: F$ELink
*
* Function: Link using Module directory entry
*
* Input:  B = Module type
*         X = Pointer to module directory entry
*
* Output: None
*
* Error:  CC = C bit set; B = error code         pshs  u         ldb   R$B,u         ldx   R$X,u         bra   L0384* System Call: F$Link
*
* Function: Link to a memory module
*
* Input:  X = Address of module name
*         A = Type/Language byte
*
* Output: X = Advanced past module name
*         Y = Module entry address
*         U = Module header address
*         A = Module type/language
*         B = Module attributes/revision byte
*
* Error:  CC = C bite set; B = error code         ldx   <D.Proc         leay  <P$DATImg,xL036F    pshs  u         ldx   R$X,u         lda   R$A,u         lbsr  L0648         bcs   L03F1         leay  ,u         ldu   ,s         stx   R$X,u         std   R$D,u         leax  ,yL0384    bitb  #ReEnt         bne   L0390         ldd   MD$Link,x         beq   L0390         ldb   #E$ModBsy         bra   L03F1L0390    ldd   MD$MPtr,x         pshs  x,b,a         ldy   MD$MPDAT,x         ldd   MD$MBSiz,x         addd  #$1FFF         tfr   a,b         lsrb           lsrb           lsrb           lsrb           lsrb           lsra           inca           lsra           lsra           lsra           lsra           pshs  a         leau  ,y         bsr   L03F5         bcc   L03BF         lda   ,s         lbsr  L0A18         bcc   L03BC         leas  $05,s         bra   L03F1L03BC    lbsr  L0A69L03BF    ldb   #$80         abx            sta   ,s         lsla           leau  a,x         ldd   ,u         incd           beq   L03CF         std   ,uL03CF    ldu   $03,s         ldd   MD$Link,u         incd           beq   L03D9         std   $06,uL03D9    puls  u,y,x,b         lbsr  L0A88         stx   $0A,u         ldx   $04,y         ldy   ,y         ldd   #$0009         lbsr  L0AE1         addd  $0A,u         std   $08,u         clrb           rts   L03F1    orcc  #$01         puls  pc,uL03F5    ldx   <D.Proc         leay  <$40,x         clra           pshs  y,x,b,a         subb  #$08         negb           lslb           leay  b,yL0403    ldw   ,s         pshs  u,yL0408    ldd   ,y++         cmpd  ,u++         bne   L041D         decw           bne   L0408         puls  u,b,a         subd  $04,s         lsrb           stb   ,s         clrb           puls  pc,y,x,b,aL041D    puls  u,y         leay  -$02,y         cmpy  $04,s         bcc   L0403         puls  pc,y,x,b,a* System Call: F$VModul
*
* Function: Verify a module
*
* Input:  X = Address of module to verify
*
* Output: U = Address of module directory entry
*
* Error:  CC = C bit set; B = error code
         pshs  u         ldx   $06,u         ldy   $01,u         bsr   L0437         ldx   ,s         stu   $0D,x         puls  u,pcL0437    pshs   x,y         lbsr   L0586
         bcs    L0495         ldd    #M$Type         lbsr  L0AE2         andb  #$0F         pshs  b,a         ldd   #$0004         lbsr  L0AE2         leax  d,x         puls  a         lbsr  L0649         puls  a         bcs   L046A         andb  #$0F         subr  a,b         bcs   L046A         ldb   #$E7         cmpx  #$C6CE         orcc  #$01L0495    puls  pc,y,xL046A    ldx   ,s         bsr   L04EC         bcs   L0464         sty   ,u         stx   $04,u         clrd           std   $06,u         ldd   #$0002         lbsr  L0AE2         addr  x,d         std   $02,u         ldy   [,u]         ldx   <u0044         pshs  u         cmpx  #$3008         cmpx  <D.ModEnd         bcc   L049D         cmpx  ,s         beq   L048C         cmpy  [,x]         bne   L048C         bsr   L04BCL049D    puls  u         ldx   <D.BlkMap         ldd   $02,u         addd  #$1FFF         lsra           lsra           lsra           lsra           lsra           ldy   ,u         tfr   a,eL04B0    ldd   ,y++         oim   #$02,d,x         dece           bne   L04B0         clrb           puls  pc,y,xL04BC    pshs  u,y,x,b,a         ldx   ,x         tfr   x,w         clrd  L04C4    ldy   ,w         beq   L04CD         std   ,w++         bra   L04C4L04CD    ldy   $02,s         ldu   ,u         puls  b,aL04D4    cmpx  ,y         bne   L04E3         stu   ,y         cmpd  $02,y         bcc   L04E1         ldd   $02,yL04E1    std   $02,yL04E3    leay  $08,y         cmpy  <D.ModEnd         bne   L04D4         puls  pc,u,y,xL04EC    pshs  u,y,x         ldd   #$0002         lbsr  L0AE2         addd  ,s         addd  #$1FFF         lsra           lsra           lsra           lsra           lsra           tfr   a,b         pshs  b         comb           lslb           sex            bsr   L0514         bcc   L0512         os9   CMDirF$A          tfr   0,u         stu   $05,s         bsr   L0514L0512    puls  pc,u,y,x,bL0514    ldx   <D.ModDAT         leax  d,x         cmpx  <D.ModEnd         bcs   L0546         ldu   $07,s         bne   L0532         ldy   <D.ModEnd         leay  $08,y         cmpr  x,y         bhi   L0546         sty   <D.ModEnd         leay  -$08,y         sty   $07,sL0532    stx   <D.ModDAT         ldd   $05,s         stx   $05,s         ldf   $02,s         clre           rolw           tfm   d+,x+         stw   ,x         rts   * Default interrupt handling routine on first booting OS9p1
L0546    orcc  #$01         rts   * Check module ID & calculate module header parity & CRC
* Entry: X=Block offset of module
*        Y=DAT image pointer of module
L0586    pshs  y,x         clrd           lbsr  L0AE2         cmpd  #$87CD         beq   L055A         ldb   #$CD         bra   L05B8* Calculate module header parity
L055A    leax  $02,x         lbsr  L0AD0         ldw   #$4A07L0563    lbsr  L0AB7         eorr  a,e         decf           bne   L0563         ince           beq   L0575         ldb   #$EC         bra   L05B8L0575    puls  y,x         lda   <D.CRC         bne   L057E         clrd           rts   * Begin checking Module CRC
* Entry: X=Module pointer
*        Y=DAT image pointer of module
L057E    ldd   #$0002         lbsr  L0AE2         tfr   d,w         pshs  y,x         ldd   #$FFFF         pshs  b,a         pshs  b         lbsr  L0AD0         leau  ,s* Loop: W=# bytes left to use in CRC calc
         tstf  L0596    bne   L05A5         pshs  x
         ldx   #1
         os9   F$Sleep
         puls  x         lbsr  L0AB9         bsr   L05BE         decw           bne   L0596         puls  x,b         cmpb  #$80         bne   L05B8         cmpx  #$0FE3         beq   L05BCL05B8    ldb   #$E8         orcc  #$01L05BC    puls  pc,y,x* Calculate 24 bit CRC
* Entry: A=Byte to add to CRC
*        U=Pointer to 24 bit CRC accumulator
*
* Future reference note: Do not use W unless preserved, contains module
*                        byte counts from routines that come here!!
L05BE    eora  ,u         pshs  a         ldd   $01,u         std   ,u         clra           ldb   ,s         asld           eora  $01,u         std   $01,u         clrb           lda   ,s         lsrd           lsrd           eord  $01,u         std   $01,u         lda   ,s         lsla           eora  ,s         sta   ,s         lsla           lsla           eora  ,s         sta   ,s         lsla           lsla           lsla           lsla           eora  ,s+         bpl   L05F6         eim   #$80,,u         eim   #$21,$02,uL05F6    rts   * System Call: F$CRC
*
* Function: Compute CRC
*
* Input:  X = Address to start computation
*         Y = Byte count
*         U = Address of 3 byte CRC accumulator
*
* Output: CRC accumulator is updated
*
* Error:  CC = C bit set; B = error code
         ldd   $08,u         beq   L0635         ldx   $06,u         pshs  x,b,a         leas  -$03,s         ldx   <D.Proc         lda   $06,x         ldb   <u00D0         ldx   $0A,u         ldy   #$0003         leau  ,s         pshs  y,x,b,a         lbsr  L0B5D         ldx   <D.Proc         leay  <$40,x         ldx   $0B,s         lbsr  L0AD2         ldw   $09,sL0621    lbsr  L0AB9         bsr   L05BE         decw           bne   L0621         puls  y,x,b,a         exg   a,b         exg   x,u         lbsr  L0B5D         leas  $07,sL0635    clrb           rts            pshs  u         lda   $01,u         ldx   $06,u         ldy   $08,u         bsr   L064B         puls  y         std   $01,y         stx   $06,yL0648    stu   $0A,y         rts   L064B    tfr   0,u         pshs  u,b,a         bsr   L06CF         cmpa  #$2F         beq   L06C8         lbsr  L06FE         bcs   L06CB         ldu   <D.ModEnd         bra   L06BEL065E    pshs  y,x,b,a         pshs  y,x         ldy   ,u         beq   L06B4         ldx   $04,u         pshs  y,x         ldd   #$0004         lbsr  L0AE4         addr  d,x         pshs  y,x         leax  $08,s         ldb   $0D,s         leay  ,s         lbsr  L07A1         leas  $04,s         puls  y,x         leas  $04,s         bcs   L06BC         ldd   #$0006         lbsr  L0AE4         sta   ,s         stb   $07,s         lda   $06,s         beq   L06AB         anda  #$F0         beq   L069F         eora  ,s         anda  #$F0         bne   L06BCL069F    lda   $06,s         anda  #$0F         beq   L06AB         eora  ,s         anda  #$0F         bne   L06BCL06AB    puls  y,x,b,a         abx            clrb           ldb   $01,s         leas  $04,s         rts   L06B4    leas  $04,s         ldd   $08,s         bne   L06BC         stu   $08,sL06BC    puls  y,x,b,aL06BE    leau  -$08,u         cmpu  <u0044         bcc   L065E         ldb   #$DD         cmpx  #$C6EB         coma  L06CB    stb   $01,s         puls  pc,u,b,aL06CF    pshs  yL06D1    lbsr  L0AD2         lbsr  L0AA4         leax  $01,x         cmpa  #$20         beq   L06D1         leax  -$01,x         pshs  b,a,ccL06E1    tfr   y,d         subd  $03,s         asrb           lbsr  L0A8B         puls  pc,y,b,a,cc         ldx   <D.Proc         leay  <$40,x         ldx   $06,u         bsr   L0701         dec   <u00ED         fcb   $41 A         bcs   L06FC         stx   $06,u         abx   L06FC    stx   $08,uL06FE    rts            pshs  yL0701    lbsr  L0AD3         pshs  y,x         bsr   L0733         cmpa  #$2E         bne   L0715         lbsr  L0AA5         bsr   L0747         lda   #$2E         bcc   L0722L0715    dec   <u0081         ble   L073F         aim   #$8D,<u0013         bsr   L0748         bcs   L0739         clrb  L0721    incb  L0722    tsta           bmi   L072B         bsr   L0734         bsr   L074E         bcc   L0721L072B    andcc #$FE         bra   L0744L072F    stx   $02,s         sty   $04,sL0734    lbra  L0ABBL0737    bsr   L072FL0739    cmpa  #$2C         beq   L0737         cmpa  #$20L073F    beq   L0737         comb           ldb   #$EBL0744    puls  y,x         bra   L06E1L0748    pshs  a         anda  #$7F         bra   L075AL074E    pshs  a         anda  #$7F         cmpa  #$2E         beq   L077B         cmpa  #$2D         beq   L077BL075A    cmpa  #$7A         bhi   L077A         cmpa  #$61         bcc   L077B         cmpa  #$5F         beq   L077B         cmpa  #$5A         bhi   L077A         cmpa  #$41         bcc   L077B         cmpa  #$39         bhi   L077A         cmpa  #$30         bcc   L077B         cmpa  #$24         beq   L077BL077A    coma  L077B    puls  pc,a         ldx   <D.Proc         leay  <$40,x         ldx   $06,u         pshs  y,x         bra   L0794         ldx   <D.Proc         leay  <$40,x         ldx   $06,u         pshs  y,x         ldy   <u004CL0794    ldx   $08,u         pshs  y,x         ldd   $01,u         leax  $04,s         leay  ,s         bsr   L07A3         leas  $08,s         rts   L07A3    pshs  u,y,x,b,a         tfr   x,u         pulu  y,x         lbsr  L0AD4         pshu  y,x         ldu   $04,s         pulu  y,x         lbsr  L0AD4         bra   L07BB         ldu   $04,s         pulu  y,xL07BB    lbsr  L0ABB         pshu  y,x         pshs  a         ldu   $03,s         pulu  y,x         lbsr  L0ABB         pshu  y,x         eora  ,s         tst   ,s+         bmi   L07DE         dec   <D.ModDAT         beq   L07D9         anda  #$DF         beq   L07B8L07D9    comb           puls  pc,u,y,x,b,a         decb           bne   L07D9         anda  #$5F         bne   L07D9         clrb           puls  pc,u,y,x,b,a 
         ldd   $01,u         addd  #$00FF         clrb           std   $01,u         ldy   <D.SysMem         leay  >$00ED,y         pshs  b,a         ldx   <D.SysMem         ldb   #$20         abx   L07FC    ldb   $01,uL07FE    cmpr  x,y         bhi   L0808         comb           ldb   #$ED         bra   L083BL0808    lda   ,-y         bne   L07FC         decb           bne   L07FE         sty   ,s         lda   $01,s         lsra           lsra           lsra           lsra           lsra           ldb   $01,s         andb  #$1F         addb  $01,u         addb  #$1F         lsrb           lsrb           lsrb           lsrb           lsrb           ldx   <D.SysPrc         lbsr  L09AD         bcs   L083B         ldb   $01,u         lda   #$01L0831    sta   ,y+         decb           bne   L0831         lda   $01,s         std   $0A,u         clrb  L083B    puls  pc,u* System Call: F$SRqMem
*
* Function: Request memory
*
* F$SRqMem allocates memory from the system's 64K address space in 256 byte 'pages.'
* There are 256 of these '256 byte pages' in the system's RAM area (256*256=64K).
* The allocation map, pointed to by D.SysMem holds one byte per page, making the
* allocation map itself 256 bytes in size.
*
* Memory is allocated from the top of the system RAM map downwards.  Rel/Boot/Krn
* also reside in this area, and are loaded from $ED00-$FFFF.  Since this area is
* always allocated, we start searching for free pages from page $EC downward.
*
* F$SRqMem also updates the system memory map according to 8K DAT blocks. If an
* empty block is found, this routine re-does the 32 entries in the SMAP table to
* indicate that they are free.
*
* Input:  D = Byte count
*
* Output: U = Address of allocated memory area
*
* Error:  CC = C bit set; B = error code
         ldd   $01,u         beq   L0897         addd  #$00FF         ldb   $0B,u         beq   L084C         comb           ldb   #$D2         rts   L084C    ldb   $0A,u         beq   L0897         ldx   <D.SysMem         abx   L0853    aim   #$FE,,x+         deca           bne   L0853         ldx   <u004C         lde   #$08L085E    ldd   ,x         cmpd  #$333E         beq   L0891         ldu   <D.BlkMap         lda   d,u         cmpa  #$01         bne   L0891         tfr   x,d         subd  <u004C         lslb           lslb           lslb           lslb           ldu   <D.SysMem         addr  d,u         ldf   #$10L087E    ldd   ,u++         bne   L0891         decf           bne   L087E         ldd   ,x         ldu   <D.BlkMap         sta   d,u         ldd   #$333E         std   ,xL0891    leax  $02,x         dece           bne   L085EL0897    clrb  L0898    rts            lda   #$74         jsr   <D.BtBug         coma           lda   <u0031         bne   L0898         inc   <u0031         ldx   <D.Init         beq   L08B5         ldd   <$14,x         beq   L08B5         leax  d,x         bra   L08B8         fcb   $42 B         clr   $0F,s         andb  >$308C         adcb  >$86C1         os9   F$Link            bcs   L0898         lda   #$62         jsr   <D.BtBug         jsr   ,y         bcs   L0898         std   <u0038         stx   <u0036         lda   #$62         jsr   <D.BtBug         ldd   $04,x         ldd   d,x         cmpd  #$4E69         bne   L08DD         ldd   $09,x         jmp   d,xL08DD    ldd   <u0038         bsr   L08EFL08E1    ldx   <u004C         ldb   $0D,x         incb           ldx   <D.BlkMap         lbra  L01C6 
         ldd   $01,u         ldx   $06,uL08EF    leau  d,x         tfr   x,d         anda  #$E0         clrb           pshs  u,b,a         lsra           lsra           lsra           lsra           ldy   <u004C         leay  a,yL0901    ldd   ,x         cmpd  #$87CD         bne   L0935         ldd   $04,x         pshs  x         leax  d,xL090F    lda   ,x+         jsr   <D.BtBug         bpl   L090F         lda   #$20         jsr   <D.BtBug         puls  x         ldd   ,s         subr  d,x         tfr   y,d         os9   ModulF$F          ldw   ,s         leax  w,x         bcc   L0930         cmpb  #$E7         bne   L0935L0930    ldd   $02,x         leax  d,x         cmpx  #$3001         cmpx  $02,s         bcs   L0901         leas  $04,s         clrb           rts            ldb   $02,u         pshs  y,x,b         ldx   <D.BlkMapL0945    leay  ,x         ldb   ,sL0949    cmpx  <D.BlkMap+2         bcc   L0966         lda   ,x+         bne   L0945         decb           bne   L0949L0954    tfr   y,d         lda   ,s         stb   ,sL095A    inc   ,y+         deca           bne   L095A         puls  b         clra           std   $01,u         puls  pc,y,xL0966    comb           ldb   #$ED         stb   ,s         puls  pc,y,x,b         ldb   $02,u         pshs  y,x,b         ldx   <D.BlkMap+2L0973    ldb   ,sL0975    cmpx  <D.BlkMap         bls   L0966         lda   ,-x         bne   L0973         decb           bne   L0975         tfr   x,y         bra   L0954         ldb   $02,u         beq   L09A7         ldd   <D.BlkMap+2         subd  <D.BlkMap         subd  $06,u         bls   L09A7         tsta           bne   L0999         cmpb  $02,u         bcc   L0999         stb   $02,uL0999    ldx   <D.BlkMap         ldd   $06,u         leax  d,x         ldb   $02,uL09A1    aim   #$FE,,x+         decb           bne   L09A1L09A7    clrb           rts   * System Call: F$AllImg
*
* Function: Allocate image RAM blocks
*
* Input:  A = Starting block number
*         B = Number of blocks
*         X = Process descriptor pointer
*
* Output: None
*
* Error:  CC = C bit set; B = error code
*         ldd   $01,u         ldx   $06,u* Entry point from F$SRqMem
*
* 6309 NOTE: IF W IS USED HERE, TRY TO PRESERVE IT AS F$SRQMEM WILL
*   PROBABLY END UP USING ITL09AD    pshs  u,y,x,b,a         lsla           leay  <$40,x         leay  a,y         clra           tfr   d,x         ldu   <D.BlkMap         pshs  u,y,x,b,aL09BC    ldd   ,y++         cmpd  #$333E         beq   L09D0         lda   d,u         cmpa  #$01         puls  b,a         bne   L09E5         decd           pshs  b,aL09D0    leax  -$01,x         bne   L09BC         ldx   ,s++         beq   L09EEL09D8    lda   ,u+         bne   L09E0         leax  -$01,x         beq   L09EEL09E0    cmpu  <D.BlkMap+2         bcs   L09D8L09E5    ldb   #$CF         leas  $06,s         stb   $01,s         comb           puls  pc,u,y,x,b,aL09EE    puls  u,y,xL09F0    ldd   ,y++         cmpd  #$333E         bne   L0A04L09F8    lda   ,u+         bne   L09F8         inc   ,-u         tfr   u,d         subd  <D.BlkMap         std   -$02,yL0A04    leax  -$01,x         bne   L09F0         ldx   $02,s         oim   #$10,$0C,x         clrb           puls  pc,u,y,x,b,a         ldb   $02,u         ldy   $08,u         bsr   L0A1CL0A17    bcs   L0A1B         sta   $01,uL0A1B    rts   L0A1C    tfr   b,a         suba  #$09         nega           pshs  x,b,a         ldd   #$FFFFL0A26    pshs  b,aL0A28    clra           ldb   $02,s         addb  ,s         stb   $02,s         cmpb  $01,s         bne   L0A45         ldb   #$CF         cmpy  <u004C         bne   L0A3C         ldb   #$EDL0A3C    stb   $03,s         comb           bra   L0A52L0A41    tfr   a,b         addb  $02,sL0A45    lslb           ldx   b,y         cmpx  #$333E         bne   L0A28         inca           cmpa  $03,s         bne   L0A41L0A52    leas  $02,s         puls  pc,x,b,a         ldb   $02,u         ldy   $08,u         bsr   L0A5F         bra   L0A17L0A5F    lda   #$FF         pshs  x,b,a         nega           subb  #$09         negb           bra   L0A26L0A69    ldd   $01,u         ldx   $06,u         ldu   $0A,u         pshs  u,y,x,b,a         leay  <$40,x         lsla           leay  a,y         clra           lslb           tfr   d,w         tfm   u+,y+         oim   #$10,$0C,x         clrb           puls  pc,u,y,x,b,a         ldb   $02,u         ldx   $06,uL0A88    bsr   L0A8E         stx   $06,u         clrb           rts   L0A8E    pshs  b         tfr   b,a         lsla           lsla           lsla           lsla           lsla           clrb           addr  d,x         puls  pc,b         ldx   $06,u         ldy   $08,u         bsr   L0AA7L0AA4    sta   $01,u         rts   L0AA7    lda   $01,y         clrb           pshs  cc         orcc  #$50         sta   >$FFA0         brn   L0AA7         lda   ,x         stb   >$FFA0         brn   L0AA7         puls  pc,cc         lda   $01,y         pshs  b,cc         clrb           orcc  #$50         sta   >$FFA0         lda   ,x+         stb   >$FFA0         puls  b,cc         bra   L0AD5L0ACF    leax  >-$2000,xL0AD3    leay  $02,yL0AD5    cmpx  #$2000         bcc   L0ACF         rts            ldd   $01,u         leau  $06,u         pulu  y,xL0AE1    bsr   L0AE7         std   -$09,u         clrb           rts   L0AE7    pshs  u,y,x         addr  d,x         bsr   L0AD5         ldu   <u004C         clra           ldb   $03,u         tfr   d,u         lda   $01,y         ldb   $03,y         pshs  cc         orcc  #$50         std   >$FFA0         ldd   ,x         stu   >$FFA0         puls  pc,u,y,x,cc         ldd   $08,u         beq   L0B53         addd  $0A,u         cmpa  #$FE         bcc   L0B53         leas  -$10,s         leay  ,s         pshs  u,y         ldx   <D.Proc         ldf   $06,x         leay  <$40,x         ldx   $01,u         lde   #$08         ldu   ,sL0B26    clrd           bsr   L0AE7         std   ,u++         leax  $02,x         dece           bne   L0B26         ldu   $02,s         lbsr  L0C96         bcs   L0B4F         tfr   b,e         lslb           ldx   <u00A1         ldu   ,s         stu   b,x         ldu   $02,s         tfr   w,d         pshs  a         bsr   L0B57         puls  b         lbsr  L0CB1L0B4F    leas  <$14,s         rts   L0B53    clrb           rts            ldd   $01,uL0B57    ldy   $08,u         beq   L0B53         ldx   $06,u         ldu   $0A,u         pshs  u,y,x,b,a         pshs  y,b,a         tfr   a,b         lbsr  L0C06         leay  a,u         pshs  y,x         ldb   $09,s         ldx   $0E,s         lbsr  L0C06         leay  a,u         pshs  y,x         ldd   #$2000         subd  ,s         pshs  b,a         ldd   #$2000         subd  $06,s         pshs  b,a         ldx   $08,s         leax  >-$6000,x         ldu   $04,s         leau  >-$4000,u         ldy   <u004C         lda   $0B,y         ldb   $0D,y         tfr   d,y         ldd   [<$06,s]         ldw   [<$0D,s]         dec   <u001F         eorb  >$10A6         jmp   -$10,x         cmpa  ,s         bls   L0BB0         ldw   ,sL0BB0    cmpw  $02,s         bls   L0BB8         ldw   $02,sL0BB8    cmpw  #$0100         bls   L0BC2         ldw   #$0100L0BC2    stw   $0C,s         orcc  #$50         std   >$FFA5         tfm   x+,u+         sty   >$FFA5         andcc #$AF         ldd   $0E,s         subd  $0C,s         beq   L0BFF         std   $0E,s         ldd   ,s         subd  $0C,s         bne   L0BEA         lda   #$20         subr  d,x         inc   $0B,s         inc   $0B,sL0BEA    std   ,s         ldd   $02,s         subd  $0C,s         bne   L0BFB         lda   #$20         subr  d,u         inc   $07,s         inc   $07,sL0BFB    std   $02,s         bra   L0B9CL0BFF    leas  <$10,s         clrb           puls  pc,u,y,x,b,a         tfr   u,yL0C07    ldu   <u00A1         lslb           ldu   b,u         tfr   x,d         anda  #$E0         beq   L0C1A         clrb           subr  d,x         lsra           lsra           lsra           lsra  L0C1A    rts            ldb   $02,u         ldx   $06,u         pshs  u,x,a,cc         bsr   L0C07L0C23    ldd   a,u         clra           orcc  #$50         stb   >$FFA0         ldb   ,x         sta   >$FFA0         puls  u,x,a,cc         stb   $01,u         clrb           rts            ldd   $01,u         ldx   $06,u         andcc #$FE         pshs  u,x,b,a,ccL0C3E    bsr   L0C07         ldd   a,u         lda   $01,s         orcc  #$50         stb   >$FFA0         sta   ,x         clrb           stb   >$FFA0         puls  pc,u,x,b,a,cc         ldx   $06,u         ldb   $06,x         bne   L0C5F         bsr   L0C97L0C59    bcs   L0C60         stb   $06,x         bsr   L0C73L0C5F    clrb  L0C60    rts            ldx   $06,uL0C63    ldb   $06,x         beq   L0C5F         clr   $06,x         bra   L0CB2         tim   #$10,$0C,x         beq   L0C60         cmpx  #$AE46L0C73    aim   #$EF,$0C,x         clr   <D.Task1N         andcc #$FE         pshs  u,x,b,a,cc         ldb   $06,x         leau  <$40,x         ldx   <u00A1         lslb           stu   b,x         cmpb  #$02         bhi   L0C90         ldx   #$FFA0         lbsr  L0E89L0C90    puls  pc,u,x,b,a,cc         bsr   L0C97         stb   $02,uL0C96    rts   L0C97    pshs  x         ldb   #$02         ldx   <u0020         lda   b,x         beq   L0CAE         dec   <u005C         cmpb  #$20         bne   L0C9E         comb           ldb   #$EF         puls  pc,x         stb   b,xL0CAE    clra           puls  pc,xL0CB1    ldb   $02,u         pshs  x,b         tstb           beq   L0CBC         ldx   <u0020         clr   b,xL0CBC    puls  pc,x,b         ldx   <u0056         beq   L0CE6         tim   #$40,$0C,x         beq   L0CE6         ldu   $04,x         ldd   $06,u         decd           std   $06,u         bne   L0CE6L0CD1    ldu   $0D,x         bsr   L0CF7         leax  ,u         beq   L0CE4         tim   #$40,$0C,x         beq   L0CE4         ldu   $04,x         ldd   $06,u         beq   L0CD1L0CE4    stx   <u0056L0CE6    tst   <u000A         ble   L0D10         rol   <u000C         ble   L0C8C         negb           beq   L0CF4         oim   #$20,$0C,xL0CF4    clrb           rts            ldx   $06,u         clrb           pshs  u,y,x,b,cc         lda   $0D,x         dec   <D.CCStk         tim   #$1A,<D.Proc         ldu   #$0045         bra   L0D14         dec   <u006C         fcb   $4B K         bne   L0D0E         dec   $0B,uL0D0E    cmpa  $0B,uL0D10    bhi   L0D14         leay  ,uL0D14    ldu   $0D,u         bne   L0D08         ldd   $0D,y         stx   $0D,y         std   $0D,x         puls  pc,u,y,x,b,cc* system IRQ service routine         ldx   <D.Proc         sts   P$SP,x         lds   <D.SysStk         ldd   <D.SysSvc         std   <D.SWI2         ldd   <D.SysIRQ         std   <D.XIRQ         jsr   [>D.SvcIRQ]         bcc   L0D4A         ldx   <D.Proc         ldb   $06,x         ldx   $04,x         pshs  u,b,a,cc         leau  ,s         lbsr  L0C23         puls  u,b,a,cc         ora   #$50         lbsr  L0C3EL0D4A    orcc  #$50         ldx   <D.Proc         tst   <u003F         lbne  L0DE1         lda   $0C,x         bita  #$20         bne   L0D71         ldu   #$0045         ldb   #$08         ldu   $0D,u         beq   L0D70         dec   <u00E5         inca           bne   L0D60         ldb   $0D,x         dec   <u00E1         deca           bcs   L0D73         ldu   $04,xL0D71    bra   L0DADL0D73    anda  #$DF         sta   $0C,xL0D77    bsr   L0CFC* System Call: F$NProc
*
* Function: Start the next process in the active queue
*
* Input: NoneFNProc   ldx   <D.SysPrc      get system process descriptor         stx   <D.Proc        save it as current         lds   <D.SysStk      get system stack pointer         andcc #^IntMasks     re-enable interupts         fcb   $8c            skip 2 bytesL00D83   cwai  #^IntMasks     re-enable interrupts and wait for one         orcc  #IntMasks      shut them down again         lda   #Suspend         ldx   #D.AProcQ-P$Queue   for start of loop, setup to point to current processL0D8C    leay  ,x             point Y to previous link (process dsc. pointer)         ldx   P$Queue,y      get process descriptor for next active process         beq   L0D83          none, allow any pending IRQ’s & try again         bita  P$State,x      is it suspended?         bne   L0D8C          yes, skip it & try again         ldd   P$Queue,x      get next process disc in line after found one         std   P$Queue,y      save the next one in line in previous’ next ptr         stx   <D.Proc        make new process current         lbsr  L0C59          check or make a task # for the found process         bcs   L0D77          couldn’t get one, go to the next process         lda   <D.TSlice      reload # ticks this process can run         sta   <D.Slice       save as tick counter for process         ldu   P$SP,x         get process stack pointer         lda   P$State,x      get it’s state         lbmi  L0E3C          if in system state, switch to it (task 0)L0DAD    bita  #Condem        was it condemned by a deadly signal?         bne   L0E05          yes go exit with error         lbsr  L0C71          do a F$SetTsk if the ImgChg flag is set         ldb   <P$Signal,x    any signals?         beq   L0DE3          no go on         decb                 is it a wakeup signal?         beq   L0DE0          yes, go wake it up         leas  -R$Size,s      make a register buffer on stack         leau  ,s             point to it         lbsr  L02C8          copy the stack from process to our copy         lda   <P$Signal,x    get last signal         sta   R$B,u          save it to process’ B         ldd   <P$SigVec,x    any intercept trap?         beq   L0E05          no, go force the process to F$Exit         std   P$PC,u         save vector to to it’s PC         ldd   <P$SigDat,x    get pointer to intercept data area         std   R$U,u         ldd   P$SP,x         subd  #R$SizeL0DD9    std   P$SP,x         lbsr  L02D7         leas  R$Size,sL0DE0    clr   <P$Signal,xL0DE3    oim   #$01,<D.Quick         ldu   <D.UsrSvc         stu   <D.SWI2         ldu   <D.UsrIRQ         stu   <D.XIRQ         ldb   P$Task,x         lslb           ldy   P$Task,x         lbsr  L0E82          remap DAT image* this is added by Alan
* it grabs and modifies values from the system process descriptor directly using
* values in that P$DATImg starting at $0640         ldb   >$0660         stb   >$0643         incb           stb   >$0645

L0E01    ldb   <D.Quick         bra   L0E52L0E05    oim   #SysState,P$State,x         leas  >P$Stack,x         andcc #^IntMasks         ldb   <P$Signal,x         clr   <P$Signal,x         os9   F$Exit            jmp   [>D.Poll]* The following routines must appear no earlier than $E00 when assembled, as
* they have to always be in the vector RAM page ($FE00-$FEFF)
		
* Default routine for D.SysIRQ
SysIRQ   lda   <D.SSTskN        get current task’s GIME task # (0 or 1)         beq   L0E32            use super-fast version for system state         clr   <D.SSTskN        clear out memory copy         jsr   [>D.SvcIRQ]      normally routine in Clock calling D.Poll         inc   <D.SSTskN        save task # for system state         lda   #$01             task 1         ora   <D.TINIT         merge task bit bit’s into shadow version         sta   <D.TINIT         update shadow         sta   >DAT.Task        save to GIME as well & returnL0E30    bra   L0E36* L0E32    jsr   [>D.SvcIRQ]L0E36    bcc   L0E3B         oim   #IntMasks,0,s    setup RTI to shut off interrupts againL0E3B    rti   * return from a system callL0E3C    clra                   force system task # to 0 (non-GRFDRV)         ldx   <D.SysPrc        get sytem process dsc. otr         lbsr  L0C71            check image, and F$SetTsk (reserves A)         orcc  #IntMasks        shut down interrupts         sta   <D.SSTskN        save task # for system state         beq   L0E4F            if task 0 skip subroutine         ora   <D.TINIT         sta   <D.TINIT         sta   >DAT.TaskL0E4F    leas  ,u         rti   * switch to new process X=process descriptor pointer, U=stack pointerL0E52    oim   #$01,<D.TINIT         lda   <D.TINIT         sta   >DAT.Task        save it to GIME         leas  ,y               point to new stack         tstb  L0E5D    bne   L0E68         ldf   #R$Size         ldu   #$FEDF         tfm   u+,y+L0E68    rti   * execute routine in task 1 pointed to by U 
L0E69    oim   #$01,<D.TINIT         ldb   <D.TINIT         stb   >DAT.Task         jmp   ,u* flip to task 1 (used by GRF/WindInt to switch to GRFDRV)         ldb   #$02         bsr   L0E82         oim   #$01,<D.TINIT         lda   <D.TINIT         sta   >DAT.Task         inc   <D.SSTskN         rti   * setup MMU in task 1, B=task # to swap to, shifted left 1 bitL0E82    cmpb  <D.Task1N         beq   L0E9E         stb   <D.Task1N         ldx   #$FFA8         ldu   <u00A1         ldu   b,u         leau  $01,u         lde   #$04L0E94    lda   ,u++         ldb   ,u++         std   ,x++         dece           bne   L0E94L0E9E    rts   FIRQVCT  ldx   #$00F6         bra   L0EA9IRQQVC   orcc  #$50         ldx   #D.IRQL0EA9    clra           sta   >DAT.Task         tfr   0,dpL0EAF    aim   #$FE,<D.TINIT         lda   <D.TINITL0EB4    sta   >DAT.Task         jmp   [,x]SWI3VCT  orcc  #$50         ldx   #D.SWI3         bra   L0EC5SWI2VCT  orcc  #$50         ldx   #D.SWI2L0EC5    ldb   [R$PC,s]         clr   >DAT.Task         tfr   0,dp         lda   <D.TINIT         bita  #$01         beq   L0EB4         tst   <D.SSTskN         bne   L0EAF         sta   >DAT.Task         leay  swistk,pc
         tfr   s,u
         ldw   #R$Size
         tfm   u+,y+
         bra   L0EA9

SWIVCT   ldx   #D.SWI
         bra   L0EC5

NMIVCT   ldx   #$00FC
         bra   L0EA9
         emodeom      equ   ** What follows after the kernel module is the register stack, starting
* at $FEDD (6309) or $FEDF (6809).  This register stack area is used by
* the kernel to save the caller's registers in the $FEXX area of memory
* because it doesn't* get "switched out" no matter the contents of the
* MMU registers.
swistk		
	fcc     /REGISTER STACK/	same # bytes as R$Size for 6809
	IFNE	H6309
	fcc	/63/	if 6309, add two more spaces
	ENDC	
		
	fcb	$55	D.ErrRst
		
* This list of addresses ends up at $FEEE after the kernel track is loaded
* into memory.  All interrupts come through the 6809 vectors at $FFF0-$FFFE
* and get directed to here.  From here, the BRA takes CPU control to the
* various handlers in the kernel.
	bra	SWI3VCT	SWI3 vector comes here
	nop	
	bra	SWI2VCT	SWI2 vector comes here
	nop	
	bra	FIRQVCT	FIRQ vector comes here
	nop	
	bra	IRQVCT	IRQ vector comes here
	nop	
	bra	SWIVCT	SWI vector comes here
	nop	
	bra	NMIVCT	NMI vector comes here
	nop	
         end